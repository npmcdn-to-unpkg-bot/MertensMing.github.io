---
title: 正则表达式基础笔记
date: 2016-03-06 22:24:20
categories: JavaScript
tags: [正则表达式, JavaScript]
---
**参考资料**

[慕课网-鬼斧神工之正则表达式](http://www.imooc.com/learn/350)
[正则表达式后向引用详解](http://c.biancheng.net/cpp/html/1413.html)
[正则表达式30分钟入门教程](http://deerchao.net/tutorials/regex/regex-1.htm)

# 什么是正则表达式？

正则表达式是字符串的搜索和匹配的工具。

## 正则表达式工具

[**一个测试正则表达式的工具 regexpal -- 中文版**](http://regexpal.isbadguy.com/)

# 基本语法

## 界定符 `//`

表示一个正则表达式的开始和结束

`/0-9/` 界定符就是包含正则表达式在中间的两个斜杠

<!--more-->

## 原子

### 可见原子

- 标点
- 英文字母数字
- 汉字、日文、阿拉伯文等语言文字
- 数理化公式符号
- 其他可见字符

### 不可见原子

- 换行符 `\n`
- 回车 `\r`
- 制表符 `\t`
- 空格
- 其他不可见的符号

## 字符转义
如果想查找元字符本身的话，就要使用 `\` 来取消这些字符的特殊意义
例如：`\.` `\*` `\\` 

## 元字符

### 定义原子的筛选方式

代码 / 语法 | 说明
:---: |:----:
`｜` | 匹配两个或多个分支选择
`[]` | 匹配方括号中的任意一个原子
`[^]` | 匹配除了方括号中的原子之外的任意字符

### 原子的集合

代码 / 语法 | 说明
:---: | :----:
`.` | 匹配除换行符以外的任何字符 `[^\n]`
`\d` | 匹配数字 `[0-9]`
`\D` | 匹配非数字 `[^0-9]`
`\s` | 匹配一个不可见原子 `[\f\n\r\t\v]`
`\S` | 匹配一个可见原子 `[^f\n\r\t\v]`
`\w` | 匹配字母或数字或下划线 `[0-9a-zA-Z_]`
`\W` | 匹配非字母或数字或下划线 `[^0-9a-zA-Z_]`

```javascript
// 匹配一个或者更多连续的数字
var pattern = /\d+/;
/*
* 比如一个网站要求你填写的 QQ 号必须是 5-12 位的数字时，可以使用 ^\d{5,12}$
* {5,12} 表示重复次数不少于 5 次，不能多于 12 次，否则都不匹配
* 有些正则表达式处理工具还有一个处理多行的选项，如果选中了这个选项
* ^ 和 $ 的意义就变成了匹配行的开始处和结束处
*/
```

## 量词
**限定符** -- 指定数量的代码

代码 / 语法 | 说明
:---: |:----:
`*` | 重复 0 次或更多次
`+` | 重复一次或更多次
`？` | 重复 0 次或 1 次
`{n}` | 恰好重复 n 次
`{n, }` | 最少重复 n 次
`{n, m}` | 重复 n 次到 m 次

```javascript
// 匹配刚好 6 个字符的单词
var pattern = /\bw{6}\b/;
```

## 边界控制

代码 / 语法 | 说明
:---: |:----:
`^` | 匹配字符串开始的位置
`$` | 匹配字符串结尾的位置
`\b` | 匹配单词的开始或结束
`\B` | 匹配非单词的开始或结束

### 使用示例

```javascript
// 匹配以字母 a 开头的单词
var pattern = /\ba\w*\b/;

/*
* 先是某个单词的开头处 \b
* 然后是字母 a
* 然后是任意数量的字母或数字 \w*
* 最后是单词的结束处 \b
*/
```

## 分组

代码 / 语法 | 说明
:---: |:----:
`()` | 匹配其中的整体作为原子

重复单个字符，直接在字符后面加上限定符就行了；
如果想要重复多个字符，可以用小括号来指定 **子表达式**（也叫 **分组**），然后可以指定这个 **分组**的重复次数，也可以对这个 **分组**进行其他的一些操作。

```javascript
// 这个表达式可以匹配几种格式的电话号码，像 `(010)88886666`，或 `022-22334455`，或 `02912345678` 等
var pattern = /\(?0\d{2}[) -]?\d{8}/;
```

1. 首先是一个转义字符 `\(`，他能出现 1 次或 0 次（`?`）
2. 然后是一个 `0`，后面跟着两个数字 `\d{2}`，
3. 然后是 `)` 或 `空格` 或 `-` 中的一个，它出现 1 次或不出现 `[) -]?`
4. 最后是 8 个数字 `\d{8}`

# 修正模式 

修正模式可以理解成是给正则表达式的匹配过程指定一种模式。

## 贪婪模式 & 懒惰模式

匹配结果怎么会有歧义呢？看看下面的代码就知道了：

```javascript
var pattern = /mertens.+1994/; 
var str = 'mertens__199419941994199419941994';
```

上面那段代码就是有歧义的了，看上去可以是匹配到 `mertens__199419941994199419941994`，也可能匹配到 `mertens__1994`。

**贪婪**：匹配结果存在歧义的时候取其长
**懒惰**：匹配结果存在歧义的时候取其短

**未经修饰的量词就是贪心量词，末尾加上`?`则使量词变懒惰。**

```javascript
// 贪婪模式
var pattern1 = /mertens.+1994/; 
var str = 'mertens__199419941994199419941994';
var result1 = str.match(pattern1);
console.log(result1); // mertens__199419941994199419941994

// 懒惰模式
var pattern2 = /mertens.+?1994/; 
var str = 'mertens__199419941994199419941994';
var result2 = str.match(pattern2);
console.log(result2); // mertens__1994
```

# 后向引用

分组捕获的内容可以在表达式或其他程序中作进一步的处理。

## 组号

默认情况下，每个分组会自动拥有一个`组号`。

分配组号的规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为 1，第二个为 2，以此类推。 

`后向引用`用于重复搜索前面某个分组匹配的文本。

```javascript
// \1 表示分组 1 匹配的某个文本
// 匹配连着的两个重复的单词
var pattern = /\b(w+)\b\s+\1\b/;
```

## 组名

可以 **指定子表达式的组名** 

```javascript
// 可以指定组名为 Word
// 使用这样的语法：(?<Word>\w+)
// 把尖括号换成'也行：(?'Word'\w+))
// 这样就把\w+的组名指定为 Word 了
// 要反向引用这个分组捕获的内容，可以使用 \k<Word>
var pattern = /(?<Word>\w+) (?'Wrod'\w+)/;

// 上一个例子也可以写成这样
var pattern = /\b(?<Word>\w+)\b\s+\k<Word>\b/;
```

## 零宽断言（zero-length assertions）

使用小括号的时候，还有很多特定用途的语法：

> 零宽的意思是指该位置是不占宽度的，也就是只作断言判断，但不匹配实际的内容；
> `\d(?=\.)` 这个正向先行断言就`只匹配点号之前的数字`，但是它`并不会匹配到这个点号`，这个 `\d(?=\.)` 括号中的匹配内容也就是零宽了。

>    零宽断言分为四种，分别是：
>    正向先行(`Positive Lookahead`)
>    正向回顾(`Positive Lookbehind`)
>    负向先行(`Negative Lookahead`)
>    负向回顾(`Negative Lookbehind`)

- `正向` 和 `负向` 的意思是断言括号中的内容是匹配还是不匹配
- `先行` 与 `回顾` 的意思是实际匹配的内容在断言内容的前面还是后面

<img src="1.jpg">

### 正向先行(Positive Lookahead)

`(?=exp)` 它断言自身出现的位置的后面能匹配 `表达式exp`。

```javascript
// 匹配以ing结尾的单词的前面部分(除了ing以外的部分)
var pattern = /\b\w+(?=ing\b)/g;

// I'm singing while you're dancing.时，它会匹配 sing 和 danc
var str = "I'm singing while you're dancing.";

console.dir(str.match(pattern));
```

<div style="overflow: hidden;"><img src="2.jpg" style="float: left;"></div>

### 正向回顾 (Positive Lookbehind)

**js 不支持！**

`(?<=exp)` 断言自身出现的位置的前面能匹配 `表达式exp`。

它的语法是：`(?<=...)` 比如 `（?<＝\.）\w` 所匹配的就是点号之后的 `ASCII` 字符。


### 负向先行(Negative Lookahead)

负向与正向意思相反， 正向是断言内容必须出现，而负向则是断言内容必须不出现。


### 负向回顾(Negative Lookbehind)

正负向与先行回顾的概念都已在前面列出， 负向回顾的理解应该就很顺了。

负向回顾的语法是：`(?<!...)`。 

比如 `(?<!Java)Script` 该正则只匹配不是 `JavaScript` 的 `Script`，它就能正确匹配 `ECMAScript` 和 `Script`。




