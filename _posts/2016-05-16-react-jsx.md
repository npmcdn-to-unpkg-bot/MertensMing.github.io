---
title: React 入门 —— 理解 JSX 和组件
date: 2016-05-16 14:42:04
categories: JavaScript
tags: React
---
> **学习资料**
> [理解JSX和组件](http://www.infoq.com/cn/articles/react-jsx-and-component)

## 什么是 JSX？

React的核心机制之一就是`虚拟DOM`：可以在内存中创建的`虚拟DOM元素`。
React利用虚拟DOM来`减少对实际DOM的操作`从而提升性能。
类似于真实的原生DOM，虚拟DOM也可以通过JavaScript来创建，例如：

```js
var child1 = React.createElement('li', null, 'First Text Content');
var child2 = React.createElement('li', null, 'Second Text Content');
var root = React.createElement('ul', { className: 'my-list' }, child1, child2);
```

使用这样的机制，我们完全可以用JavaScript构建完整的界面DOM树，正如我们可以用JavaScript创建真实DOM。
**`但这样的代码可读性并不好，于是React发明了JSX，利用我们熟悉的HTML语法来创建虚拟DOM：`**

```html
var root =(
  <ul className="my-list">
    <li>First Text Content</li>
    <li>Second Text Content</li>
  </ul>
);
```

<!-- more -->

上面两段代码是完全等价的，后者将XML语法直接加入到JavaScript代码中，让你能够高效的通过代码而不是模板来定义界面。之后JSX通过翻译器转换到纯JavaScript再由浏览器执行。
在实际开发中，JSX在`产品打包阶段都已经编译成纯JavaScript`，JSX的语法不会带来任何性能影响。
另外，由于JSX只是一种语法，因此JavaScript的关键字`class`, `for`等也不能出现在XML中，而要如例子中所示，使用`className`, `htmlFor`代替，这和原生DOM在JavaScript中的创建也是一致的。

> 因此，JSX本身并不是什么高深的技术，可以说只是一个比较高级但很直观的语法糖。
> 它非常有用，却不是一个必需品，没有JSX的React也可以正常工作：
> 只要你乐意用JavaScript代码去创建这些虚拟DOM元素。

## 为什么使用JSX？

前端界面的最基本功能在于展现数据，为此大多数框架都使用了模板引擎，例如在`AngularJS`中：

```html
<div ng-if="person != null">
    Welcome back, <b>{{person.firstName}} {{person.lastName}}</b>!
</div>
<div ng-if="person == null">
    Please log in.
</div>
```

在`EmberJS`中：

```js
{{#if person}}
  Welcome back, <b>{{person.firstName}} {{person.lastName}}</b>!
{{else}}
  Please log in.
{{/if}}
```

模板可以直观的定义UI来展现Model中的数据，你不必手动的去拼出一个很长的HTML字符串，几乎每种框架都有自己的模板引擎。

传统MVC框架强调界面展示逻辑和业务逻辑的分离，因此为了应对复杂的展示逻辑需求，这些模板引擎几乎都不可避免的需要发展成一门独立的语言，如上面代码所示，`每个框架都有自己的模板语言语法`。而这无疑`增加了框架的门槛和复杂度`。

如果说掌握一种模板语言并不是很大的问题，那么其实由模板带来的架构复杂性则是让框架也变得复杂的重要原因之一，例如：

模板需要对应数据模型，即上下文，如何去绑定和实现？
`-` 模板可以嵌套，不同部分界面可能来自不同数据模型，如何处理？
`-` 模板语言终究是一个轻量级语言，为了满足项目需求，你很可能需要扩展模板引擎的功能。
`-` 为了解决这些复杂度，框架本身需要精心的设计，以及创造新的概念（例如Angular的Directive）。
`-` 这些都会让框架变得复杂和难以掌握，不仅增加了开发成本，各种难以调试的Bug还会降低开发质量。

> 正因为如此，React直接放弃了模板而发明了JSX。
> 看上去很像模板语言，但其本质是`通过代码来构建界面`，这使得我们不再需要掌握一门新的语言就可以直观的去定义用户界面：掌握了JavaScript就已经掌握了JSX。

这里不妨再引用之前文章举过的例子，在展示一个列表时，模板语言通常提供名为`Repeat`的语法，例如在`Angular`中：

```html
<ul class="unstyled">
  <li ng-repeat="todo in todoList.todos">
    <input type="checkbox" ng-model="todo.done">
    <span class="done-{{todo.done}}">{{todo.text}}</span>
  </li>
</ul>
```

而使用JSX，则代码如下：

```html
var lis = this.todoList.todos.map(function (todo) {
  return  (
    <li>
      <input type="checkbox" checked={todo.done}>
      <span className={'done-' + todo.done}>{todo.text}</span>
    </li>
  );
});

var ul = (
  <ul class="unstyled">
    {lis}
  </ul>
);
```

可以看到，JSX完美利用了JavaScript自带的语法和特性，我们只要记住HTML只是代码创建DOM的一种语法形式，就很容易理解JSX。
而这种使用代码构建界面的方式，完全消除了业务逻辑和界面元素之间的隔阂，让代码更加直观和易于维护。

## JSX的语法

JSX本身就和XML语法类似，可以`定义属性以及子元素`。
唯一特殊的是可以用大括号来加入JavaScript表达式，例如：

```html
var person = <Person name={window.isLoggedIn ? window.name : ''} />;
```

`-` 一般每个组件都定义了一组属性（`props`，`properties`的简写）接收输入参数，这些属性通过XML标记的属性来指定。
`-` `大括号`中的语法就是`纯JavaScript表达式`，`返回值会赋予组件的对应属性`，因此可以使用任何JavaScript变量或者函数调用。

上述代码经过JSX编译后会得到：

```js
var person = React.createElement(
  Person,
  {name: window.isLoggedIn ? window.name : ''}
);
```

对于子元素也是类似，大括号中使用JavaScript表达式来返回需要展现的元素，例如文章开头提到的例子使用JSX可以写成：

```html
var node = (
  <div className="container">
    {
       person ? <span>Welcome back, <b>{person.firstName} {person.lastName}</b>!</span>
       : <span>Please log in</span>
    }
  </div>
);
```

既然大括号中是JavaScript，而JSX又允许在JavaScript中使用XML，因此在大括号中仍然可以使用XML来声明组件，不断`递归使用`。

如果需要`展现一组子节点`，只需`表达式返回一个JavaScript数组`，`数组的每个元素都是一个React组件`，例如上一节的例子，其中lis就是有多个“li”元素的数组。

```html
var ul = (
  <ul class="unstyled">
    {lis}
  </ul>
);
```

## 在JSX中使用事件

幸运的是，现在JSX可以让事件绑定返璞归真：

```html
<button onClick={this.checkAndSubmit.bind(this)}>Submit</button>
```

和原生HTML定义事件的唯一区别就是`JSX采用驼峰写法来描述事件名称`，
大括号中仍然是标准的JavaScript表达式，返回一个事件处理函数。

在JSX中你不需要关心什么时机去移除事件绑定，因为`React`会在对应的真实`DOM`节点移除时就自动解除了事件绑定。

### React模拟事件系统
> React并不会真正的绑定事件到每一个具体的元素上，而是采用事件代理的模式：
> 在根节点`document`上为每种事件添加唯一的`Listener`，然后通过事件的`target`找到真实的触发元素。
> 这样从触发元素到顶层节点之间的所有节点如果有绑定这个事件，React都会触发对应的事件处理函数。
> 这就是所谓的`React模拟事件系统`。

尽管整个事件系统由`React`管理，但是其API和使用方法与原生事件一致。
这种机制确保了跨浏览器的一致性：
在所有浏览器（`IE8及以上`）都可以使用符合W3C标准的API，包括`stopPropagation()`，`preventDefault()`等等。
对于事件的冒泡（`bubble`）和捕获（`capture`）模式也都完全支持。

## 在JSX中使用样式

尽管在大部分场景下我们应该将样式写在独立的CSS文件中，但是有时对于`某个特定组件`而言，其样式相当简单而且独立，那么也可以将其直接定义在JSX中。

在JSX中使用样式和真实的样式也很类似，通过`style属性`来定义，但和真实DOM不同的是，`属性值不能是字符串而必须为对象`，例如：

```html
<div style={{color: '#ff0000', fontSize: '14px'}}>Hello World.</div>
```

在JSX中可以使用所有的的样式，基本上属性名的转换规范就是将其写成`驼峰写法`，例如“`background-color`”变为“`backgroundColor`”, “`font-size`”变为“`fontSize`”，这和标准的JavaScript操作DOM样式的API是一致的。

## 使用自定义组件

在JSX中，我们不仅可以使用React自带`div`, `input`...这些虚拟DOM元素，还可以自定义组件。
组件定义之后，也都可以利用XML语法去声明，而能够使用的XML `Tag`就是在当前JavaScript上下文的`变量名`，这一点非常好用，你不必再去考虑某个Tag是如何对应到相应的组件实现。

例如React官方教程中的例子：

```html
class HelloWorld extends React.Component{
  render() {
    return (
      <p>
        Hello, <input type="text" placeholder="Your name here" />!
        It is {this.props.date.toTimeString()}
      </p>
    );
  }
};

setInterval(function() {
  React.render(
    <HelloWorld date={new Date()} />,
    document.getElementById('example')
  );
}, 500);
```

其中声明了一个名为`HelloWorld`的组件，那么就可以在XML中使用`<HellWorld />`，这个Tag就是JavaScript变量名，我们可以`用任意变量名`：

```html
var MyHelloWorld = HelloWorld;
React.render(<MyHelloWorld />, …);
```

甚至，我们还可以`引入命名空间`：

```html
var sampleNameSpace = {
  MyHelloWorld: HelloWorld
};
React.render(<sampleNameSpace.MyHelloWorld />, …);
```

这些语法看上去有点怪，但是如果我们记住JSX语法只是JavaScript语法的一个语法映射，那么这些就非常容易理解了。

## 组件的概念和生命周期

> React使用组件来封装界面模块，整个界面就是一个大组件
> 开发过程就是不断优化和拆分界面组件、构造整个组件树的过程。
> 可以认为组件类似于其他框架中Widget（或Control）的概念，但又有所不同。
> React中的界面一切皆为组件，而Widget一般只是嵌入到界面中为完成某个功能的独立模块。

如下图，整个页面是一个大的组件，然后再将其拆分成很多小的组件。
组件机制加上JSX的语法，让你在构造界面时就像有一套符合项目需求的HTML标记，界面定义变得非常直观。

<img src="2.jpg">

### 属性 props

组件自身定义了`一组props作为对外接口`，`展示一个组件时只需要指定props作为XML节点的属性`。
组件很少需要对外公开方法，`唯一的交互途径就是props`。
这使得使用组件就像使用函数一样简单，给定一个输入，组件给定一个界面输出。
当给予的参数一定时，那么输出也是一定的。

而传统控件通常提供很多方法让你在外部改变控件的状态和行为，当控件的状态在不同场景不同逻辑中可以被随意控制时，开发和调试也会变得复杂。

而React组件`通过唯一的props接口避免了逻辑复杂性`，让开发测试都更加容易。
这种特性完全`得益于虚拟DOM机制`，让你可以`每次props改变都能以整体刷新页面`的思路去考虑界面展现逻辑。

### 根节点

> 如果`整个项目完全采用React`，那么`界面上就只有一个组件根节点`；
> 如果`局部使用React`，那么`每个局部使用的部分都有一个根节点`。

在Render时，根节点由React.render函数去触发：

```html
React.render(
  <App />,
  document.getElementById('react-root')
);
```

而所有的子节点则都是`通过父节点的render方法去构造`的。
每个组件都会有一个`render方法`，这个方法`返回组件的实例`，最终整个界面得到一个虚拟DOM树，再由React以最高效的方式展现在界面上。

### 状态 state

除了props之外，组件还有一个很重要的概念：state。

> 组件规范中定义了`setState`方法，每次调用时都会更新组件的状态，触发render方法。

需要注意，render方法是被`异步调用`的，这可以保证同步的`多个setState方法`只会`触发一次render`，有利于提高性能。

`和props不同`，`state是组件的内部状态`，除了初始化时可能由props来决定，之后就`完全由组件自身去维护`。

在组件的整个生命周期中，React强烈不推荐去修改自身的props，因为这会破坏UI和Model的一致性，props只能够由使用者来决定。

### 组件的生命周期

对于自定义组件，`唯一必须实现的方法就是render()`，除此之外，还有一些方法会在组件生命周期中被调用，如下图所示：

<img src="3.jpg">

```js
shouldComponentUpdate(nextProps, nextState) {
  return nextProps.id !== this.props.id;
}
```

[这里有详细笔记](../post/react-lifecycle/index.html)

## 使用Babel进行JSX编译

```html
npm install —save-dev babel-loader
```

只需稍微改变一下`webpack.config.js`的配置，将原来的`jsx-loader`变为`babel-loader`：

```js
module: {
  loaders: [
    { test: /\.jsx?$/, loaders: ['babel-loader']}
  ]
}
```
