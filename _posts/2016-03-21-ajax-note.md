---
title: AJAX 全接触
date: 2016-03-21 22:02:03
categories: JavaScript
tags: AJAX
---
## AJAX 的概念

`-` `Asynchronous JavaScript + XML`
`-` 这一技术能够向服务器请求额外的数据而无须卸载页面

## 一个完整的 AJAX 通信流程

### 创建 XHR 对象

**一开始，需要创建一个 `XHR` 对象，这个对象有三个属性：**

> `readyState `为 `0`
> `status` 为空
> `responseText` 为空

<!-- more -->

<img src="1.jpg" width="100%">

### 调用 open 方法

**调用 XHR 的 `open()` 方法的时候**

>  `readyState` 会变为 `1`
>  开启一个请求，但没有向服务器端发起请求。

<img src="2.jpg" width="100%">

### 调用 send 方法

**然后再调用` send()` 方法正式向服务器端发起请求**

> 然后 `readyState` 会变为 `2`

<img src="3.jpg" width="100%">

### 接收数据

**当浏览器开始返回数据的时候，浏览器开始接收数据的时候**

> `readyState` 会变为 `3`

<img src="4.jpg" width="100%">

### 请求结束

**当浏览器端结束请求的时候**

> `readyState` 会变为 `4`
> 就会有相应的 `status` 和 `responseText`

## XMLHttpRequest 对象

```js
// IE7+、 Firefox、 Opera、 Chrome 和 Safari 都支持原生的 XHR 对象
function createXHR() {
    if (typeof XMLHttpRequest != "undefined") {
        return new XMLHttpRequest();
    }
}
```

### XHR的用法

#### 调用 open 方法

在使用 XHR 对象时，要调用的第一个方法是 open()，它接受 3 个参数：
`-` 要发送的请求的类型（ "get" 、 "post" 等）
`-` 请求的 URL 
`-` 表示是否异步发送请求的布尔值

```js
xhr.open("get", "example.php", false);
/*
注意：
1. URL 相对于执行代码的当前页面（当然也可以使用绝对路径）
2. 调用 open() 方法并不会真正发送请求，而只是启动一个请求以备发送。
*/
```

#### 调用 send 方法

要发送特定的请求，必须调用 send() 方法，它接收一个参数
`-` 要作为请求主体发送的数据
`-` 如果不需要通过请求主体发送数据，则必须传入 null，因为这个参数对有些浏览器来说是必需的

```js
xhr.open("get", "example.php", false);
xhr.send(null);
// 由于这次请求是同步的， JavaScript 代码会等到服务器响应之后再继续执行。
```

#### XHR 对象的属性

在收到响应后，响应的数据会自动填充 XHR 对象的属性，相关的属性简介如下：

属性 | 介绍
:-- | :--
responseText | 作为响应主体被返回的文本
responseXML | 如果响应的内容类型是"`text/xml`" 或"`application/xml`" ，这个属性中将保存包含着响应数据的 `XML` DOM 文档
status | 响应的 `HTTP 状态`
statusText | `HTTP 状态的说明`

在接收到响应后，第一步是检查 status 属性，以确定响应已经成功返回。

Type | Reason-phrase | Note
:-- | :-- | :--
1XX | Informational | 信息性状态码，表示接受的请求正在处理
2XX | Success | 成功状态码，表示请求正常处理完毕
3XX | Redirection | 重定向状态码，表示需要客户端需要进行附加操作
4XX | Client | Error 客户端错误状态码，表示服务器无法处理请求
5XX | Server | Error 服务器错误状态码，表示服务器处理请求出错

为确保接收到适当的响应，应该像下面这样检查上述这两种状态代码：

```js
xhr.open("get", "example.txt", false);
xhr.send(null);
/* 发送同步请求*/
if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304) {
    alert(xhr.responseText);
} else {
    alert("Request was unsuccessful: " + xhr.status);
}
```

`-` 建议通过检测 `status` 来决定下一步的操作，不要依赖 `statusText`，因为后者在跨浏览器使用时不太可靠。
`-` 另外，无论内容类型是什么，响应主体的内容都会保存到 `responseText` 属性中；
`-` 而对于非 `XML` 数据而言， `responseXML` 属性的值将为 `null`

#### 发送异步的请求

如何发送异步的请求，让 `JavaScript` 继续执行而不必等待响应？

这个时候就需要用到 `XHR` 对象的 `readyState` 属性，该属性表示请求/响应过程的当前活动阶段。
只要 `readyState` 属性的值由一个值变成另一个值，都会触发一次 `readystatechange` 事件。

readyState | phrase | note
:-- | :-- | :--
0 | 未初始化 | 尚未调用 `open`() 方法
1 | 启动 | 已经调用 `open`() 方法，但尚未调用 `send`() 方法
2 | 发送 | 已经调用 `send`() 方法，但尚未接收到响应
3 | 接收 | 已经接收到部分响应数据
4 | 完成 | 已经接收到全部响应数据，而且已经可以在客户端使用了

```js
var xhr = createXHR();
// 必须在调用 open() 之前指定 onreadystatechange 事件处理程序才能确保跨浏览器兼容性
// 以上代码利用 DOM 0 级方法为 XHR 对象添加了事件处理程序，原因是并非所有浏览器都支持 DOM 2 级方法
xhr.onreadystatechange = function() {
    if (xhr.readyState == 4) {
        if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304) {
            alert(xhr.responseText);
        } else {
            alert("Request was unsuccessful: " + xhr.status);
        }
    }
};
xhr.open("get", "example.txt", true);
xhr.send(null);
```

#### 调用 abort 方法 

在接收到响应之前还可以调用 `abort()` 方法来取消异步请求，如下所示：

```js
xhr.abort();
```

`-` 调用这个方法后， XHR 对象会停止触发事件
`-` 而且也不再允许访问任何与响应有关的对象属性。
`-` 在终止请求之后，还应该对 XHR 对象进行解引用操作。
`-` 由于内存原因，不建议重用 XHR 对象。

### HTTP头部信息

`-` 每个 `HTTP` 请求和响应都会带有相应的头部信息
`-` `XHR` 对象也提供了操作这两种头部（即`请求头部`和`响应头部`）信息的方法

默认情况下，在发送 `XHR` 请求的同时，还会`发送下列头部信息`。

名称 | 描述
:-- | :--
Accept | 浏览器能够处理的内容类型。
Accept-Charset | 浏览器能够显示的字符集。
Accept-Encoding | 浏览器能够处理的压缩编码。
Accept-Language | 浏览器当前设置的语言。
Connection | 浏览器与服务器之间连接的类型。
Cookie | 当前页面设置的任何 `Cookie`。
Host | 发出请求的页面所在的域 。
Referer | 发出请求的页面的 `URI`。
User-Agent | 浏览器的用户代理字符串。

#### setRequestHeader 方法

使用 `setRequestHeader`() 方法可以设置`自定义的请求头部信息`。

> 这个方法接受两个参数：
> `头部字段的名称`和`头部字段的值`。

要成功发送请求头部信息，必须在调用 `open`() 方法之后且调用 `send`() 方法之前调用 `setRequestHeader`() 

```js
var xhr = createXHR();
xhr.onreadystatechange = function() {
    if (xhr.readyState == 4) {
        if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304) {
            alert(xhr.responseText);
        } else {
            alert("Request was unsuccessful: " + xhr.status);
        }
    }
};
xhr.open("get", "example.php", true);
// 在调用 open() 方法之后且调用 send() 方法之前调用
xhr.setRequestHeader("MyHeader", "MyValue");
xhr.send(null);
```

> 服务器在接收到这种自定义的头部信息之后，可以执行相应的后续操作。
> 建议使用自定义的头部字段名称，不要使用浏览器正常发送的字段名称，否则有可能会影响服务器的响应。
> 有的浏览器允许开发人员重写默认的头部信息，但有的浏览器则不允许这样做。

#### getResponseHeader 方法

> 调用 `XHR 对象`的 `getResponseHeader`() 方法并传入头部字段名称，可以取得`相应的响应头部信息`。
> 而调用 `getAllResponseHeaders`() 方法则可以取得一个`包含所有头部信息`的长字符串。

```js
var myHeader = xhr.getResponseHeader("MyHeader");
var allHeaders = xhr.getAllResponseHeaders();
```

> 在服务器端，也可以利用头部信息向浏览器发送额外的、结构化的数据。

在没有自定义信息的情况下， `getAllResponseHeaders`() 方法通常会返回如下所示的多行文本内容：

```html
Date: Sun, 14 Nov 2004 18:04:03 GMT
Server: Apache/1.3.29 (Unix)
Vary: Accept
X-Powered-By: PHP/4.3.8
Connection: close
Content-Type: text/html; charset=iso-8859-1
```

### GET请求

`-` `GET` 是最常见的请求类型，最常用于向服务器`查询某些信息`。
`-` 必要时，可以将`查询字符串参数`追加到 `URL` 的末尾，以便将信息发送给服务器。
`-` 对 `XHR` 而言，位于传入 `open`() 方法的 `URL` 末尾的查询字符串`必须经过正确的编码`才行。

> 查询字符串中每个参数的名称和值都必须使用 `encodeURIComponent`() 进行编码，然后才能放到 `URL` 的末尾；
> 而且所有名 -值对儿都必须由和号（` &`）分隔

```js
xhr.open("get", "example.php?name1=value1&name2=value2", true);
// 下面这个函数可以辅助向现有 URL 的末尾添加查询字符串参数：
function addURLParam(url, name, value) {
    url += (url.indexOf("?") == -1 ? "?" : "&");
    url += encodeURIComponent(name) + "=" + encodeURIComponent(value);
    return url;
}
```

下面是使用这个函数来构建请求 URL 的示例。

```js
var url = "example.php";
//添加参数
url = addURLParam(url, "name", "Nicholas");
url = addURLParam(url, "book", "Professional JavaScript");
//初始化请求
xhr.open("get", url, false);
```

### POST请求

- 通常用于向服务器发送应该被保存的数据
- POST 请求应该把数据作为请求的主体提交

在 open() 方法第一个参数的位置传入"post" ，就可以初始化一个 POST 请求

```js
xhr.open("post", "example.php", true);
```

发送 `POST` 请求的第二步就是向 `send`() 方法中传入某些数据。
可以在此传入任何想发送到服务器的字符串，也可以在此传入 `XML DOM` 文档

#### 使用 `XHR` 来模仿表单提交

默认情况下，服务器对 `POST 请求`和`提交 Web 表单的请求`并不会一视同仁。
因此，服务器端必须有程序来读取发送过来的原始数据，并从中解析出有用的部分。

> 我们可以使用 `XHR` 来模仿表单提交

首先将 `Content-Type` 头部信息设置为 `application/x-www-form-urlencoded`，也就是表单提交时的内容类型

#### 格式化数据

其次是以适当的格式创建一个字符串，`POST` 数据的格式与查询字符串格式相同

> 如果需要将页面中表单的数据进行序列化，然后再通过 `XHR` 发送到服务器，可以使用 `serialize`() 函数来创建这个字符串

#### 一个 POST 请求实例

```js
function serialize(form) {
    var parts = [],
        field = null,
        i,
        len,
        j,
        optLen,
        option,
        optValue;
    for (i = 0, len = form.elements.length; i < len; i++) {
        field = form.elements[i];
        switch (field.type) {
            case "select-one":
            case "select-multiple":
                if (field.name.length) {
                    for (j = 0, optLen = field.options.length; j < optLen; j++) {
                        option = field.options[j];
                        if (option.selected) {
                            optValue = "";
                            if (option.hasAttribute) {
                                optValue = (option.hasAttribute("value") ?
                                    option.value : option.text);
                            } else {
                                optValue = (option.attributes["value"].specified ?
                                    option.value : option.text);
                            }
                            parts.push(encodeURIComponent(field.name) + "=" +
                                encodeURIComponent(optValue));
                        }
                    }
                }
                break;
            case undefined: //字段集
            case "file": //文件输入
            case "submit": //提交按钮
            case "reset": //重置按钮
            case "button": //自定义按钮
                break;
            case "radio": //单选按钮
            case "checkbox": //复选框
                if (!field.checked) {
                    break;
                }
                /* 执行默认操作 */
            default:
                //不包含没有名字的表单字段
                if (field.name.length) {
                    parts.push(encodeURIComponent(field.name) + "=" +
                        encodeURIComponent(field.value));
                }
        }
    }
    return parts.join("&");
}

function submitData() {
    var xhr = createXHR();
    xhr.onreadystatechange = function() {
        if (xhr.readyState == 4) {
            if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304) {
                alert(xhr.responseText);
            } else {
                alert("Request was unsuccessful: " + xhr.status);
            }
        }
    };
    xhr.open("post", "postexample.php", true);
    xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
    var form = document.getElementById("user-info");
    xhr.send(serialize(form));
}
```

## XMLHttpRequest 2 级

`XMLHttpRequest 2` 级则进一步发展了 `XHR`

### FormData

`FormData` 为`序列化表单`以及`创建与表单格式相同的数据`（用于通过 `XHR` 传输）提供了便利

创建了一个 FormData 对象

```js
var data = new FormData();
data.append("name", "Nicholas");
// 可以像这样添加任意多个键值对
```

可以通过向 `FormData` 构造函数中传入表单元素，也可以用`表单元素的数据`预先向其中填入键值对儿：

```js
var data = new FormData(document.forms[0]);
```

创建了 `FormData` 的实例后，可以将它直接传给 `XHR` 的 `send`() 方法，如下所示：

```js
var xhr = createXHR();
xhr.onreadystatechange = function() {
    if (xhr.readyState == 4) {
        if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304) {
            alert(xhr.responseText);
        } else {
            alert("Request was unsuccessful: " + xhr.status);
        }
    }
};
xhr.open("post", "postexample.php", true);
var form = document.getElementById("user-info");
xhr.send(new FormData(form));
```

> 使用 `FormData` 的方便之处体现在`不必明确地在 XHR 对象上设置请求头部`。 
> `XHR` 对象能够识别传入的数据类型是 `FormData` 的实例，并`配置适当的头部信息`。
> 支持 `FormData` 的浏览器有 `Firefox 4+`、 `Safari 5+`、 `Chrome` 和` Android 3+`版 WebKit。

### 超时设定

`-` `IE8` 为 `XHR` 对象添加了一个 `timeout` 属性，表示请求在等待响应多少毫秒之后就终止。
`-` 在给`timeout` 设置一个数值后，如果在规定的时间内浏览器还没有接收到响应，那么就会触发 `timeout` 事件，进而会调用 `ontimeout` 事件处理程序。
`-` 这项功能后来也被收入了 `XMLHttpRequest 2 级规范`中。

```js
var xhr = createXHR();
xhr.onreadystatechange = function() {
    if (xhr.readyState == 4) {
        try {
            if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304) {
                alert(xhr.responseText);
            } else {
                alert("Request was unsuccessful: " + xhr.status);
            }
        } catch (ex) {
            //假设由 ontimeout 事件处理程序处理
        }
    }
};
xhr.open("get", "timeout.php", true);
xhr.timeout = 1000; //将超时设置为 1 秒钟（仅适用于 IE8+）
xhr.ontimeout = function() {
    alert("Request did not return in a second.");
};
xhr.send(null);
```

## 跨源资源共享

通过 `XHR` 实现 `Ajax` 通信的一个主要限制，来源于`跨域安全策略`。

> 默认情况下， XHR 对象只能访问与包含它的页面位于同一个域中的资源。
> 这种安全策略可以预防某些恶意行为。

`CORS`（ Cross-Origin Resource Sharing，跨源资源共享）是 W3C 的一个工作草案，定义了在`必须访问跨源资源时`，`浏览器与服务器应该如何沟通`。

> CORS 背后的基本思想，就是使用`自定义的 HTTP 头部`让`浏览器与服务器进行沟通`，从而决定请求或响应是应该成功，还是应该失败。

一个简单的使用 `GET` 或 `POST` 发送的请求，它没有自定义的头部，而主体内容是 text/plain。
在发送该请求时，需要给它`附加一个额外的 Origin 头部`，其中包含请求页面的源信息（`协议、域名和端口`），以便服务器根据这个头部信息来决定是否给予响应。

下面是 Origin 头部的一个示例：

```js
Origin: http://www.nczonline.net
```

如果服务器认为这个请求可以接受，就在 `Access-Control-Allow-Origin` 头部中回发相同的源信息（如果是公共资源，可以回发 `*` ）。

```html
Access-Control-Allow-Origin: http://www.nczonline.net
```

如果没有这个头部，或者有这个头部但源信息不匹配，浏览器就会驳回请求。正常情况下，浏览器会处理请求。

> 注意，请求和响应都不包含 cookie 信息。

### IE对CORS的实现

> 微软在 `IE8` 中引入了 `XDR`（ XDomainRequest）类型。
> 这个对象与 `XHR` 类似，但能实现安全可靠的跨域通信。 
> `XDR` 对象的安全机制部分实现了 W3C 的 `CORS 规范`。

以下是 XDR 与 XHR 的一些不同之处:

`-` `cookie` 不会随请求发送，也不会随响应返回。
`-` `只能设置`请求头部信息中的 `Content`-`Type` 字段。
`-` 不能访问响应头部信息。
`-` 只支持 `GET` 和 `POST` 请求。

`被请求的资源`可以根据它认为合适的任意数据（用户代理、来源页面等）来`决定是否设置` `Access-Control- Allow-Origin` 头部。

作为`请求`的一部分， `Origin` 头部的值表示`请求的来源域`，以便远程资源明确地识别 `XDR` 请求。

#### XDR 对象的使用方法

`1.` `XDR` 对象的使用方法与 `XHR` 对象非常相似。也是创建一个 `XDomainRequest` 的实例，调用 `open`()方法，再调用 `send`() 方法。
`2.` 但与 `XHR` 对象的 `open`() 方法不同， `XDR` 对象的 `open`() 方法`只接收两个参数`：`请求的类型和 URL`。
`3.` 所有 `XDR` 请求都是`异步`执行的，`不能`用它来`创建同步请求`。
`4.` 请求返回之后，会触发 `load` 事件，响应的数据也会保存在 `responseText` 属性中。

```js
var xdr = new XDomainRequest();
xdr.onload = function() {
    alert(xdr.responseText);
};
xdr.open("get", "http://www.somewhere-else.com/page/");
xdr.send(null);
```

`-` 在接收到响应后，你只能`访问响应的原始文本`；`没有办法确定响应的状态代码`。
`-` 而且，只要响应有效就会触发 `load` 事件，如果失败（包括响应中缺少 `Access-Control-Allow-Origin` 头部）就会触发 `error` 事件。
`-` 遗憾的是，除了错误本身之外，`没有其他信息可用`，因此唯一能够确定的就只有请求未成功了。
`-` 要检测错误，可以像下面这样指定一个 `onerror 事件处理程序`。

```js
var xdr = new XDomainRequest();
xdr.onload = function() {
    alert(xdr.responseText);
};
xdr.onerror = function() {
    alert("An error occurred.");
};
xdr.open("get", "http://www.somewhere-else.com/page/");
xdr.send(null);
```

在请求返回前调用 `abort() `方法可以终止请求：

```js
xdr.abort(); //终止请求
```

与 `XHR` 一样， `XDR` 对象也支持 `timeout` 属性以及 `ontimeout` 事件处理程序。

```js
var xdr = new XDomainRequest();
xdr.onload = function() {
    alert(xdr.responseText);
};
xdr.onerror = function() {
    alert("An error occurred.");
};
// 运行 1 秒钟后超时，并随即调用 ontimeout 事件处理程序
xdr.timeout = 1000;
xdr.ontimeout = function() {
    alert("Request took too long.");
};
xdr.open("get", "http://www.somewhere-else.com/page/");
xdr.send(null);
```

为支持 `POST` 请求， `XDR` 对象提供了 `contentType` 属性，用来表示发送数据的格式

```js
var xdr = new XDomainRequest();
xdr.onload = function() {
    alert(xdr.responseText);
};
xdr.onerror = function() {
    alert("An error occurred.");
};
xdr.open("post", "http://www.somewhere-else.com/page/");
xdr.contentType = "application/x-www-form-urlencoded";
xdr.send("name1=value1&name2=value2");
```

这个属性是通过 `XDR` 对象影响头部信息的唯一方式。

### 其他浏览器对CORS的实现

`Firefox 3.5+`、 `Safari 4+`、 `Chrome`、 iOS 版 `Safari` 和 `Android` 平台中的 `WebKit` 都通过 `XMLHttpRequest`对象实现了对 `CORS` 的原生支持。

#### 传入绝对 URL
在尝试打开不同来源的资源时，`无需额外编写代码就可以触发这个行为`。 要请求位于另一个域中的资源，使用标准的 `XHR` 对象并在 `open`() 方法中传入`绝对 URL` 即可，例如：

```js
var xhr = createXHR();
xhr.onreadystatechange = function() {
    if (xhr.readyState == 4) {
        if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304) {
            alert(xhr.responseText);
        } else {
            alert("Request was unsuccessful: " + xhr.status);
        }
    }
};
xhr.open("get", "http://www.somewhere-else.com/page/", true);
xhr.send(null);
```

与 `IE` 中的 `XDR` 对象不同，通过跨域 `XHR` 对象可以访问 `status` 和 `statusText` 属性，而且还支持同步请求。

#### 跨域 XHR 的限制

跨域 `XHR` 对象也有一些限制，但为了安全这些限制是必需的。
以下就是这些限制。

> `-` 不能使用 `setRequestHeader`() 设置自定义头部
> `-` 不能发送和接收 `cookie` 
> `-` 调用 `getAllResponseHeaders`() 方法总会返回空字符串

由于无论同源请求还是跨源请求都使用相同的接口
因此对于`本地资源`，最好使用`相对 URL`；
在访问`远程资源`时再使用`绝对 URL`。
这样做能消除歧义，避免出现限制访问头部或本地 cookie 信息等问题。

### Preflighted Reqeusts

`CORS` 通过一种叫做 `Preflighted Requests` 的透明服务器验证机制支持开发人员`使用自定义的头部`、GET 或 POST `之外的方法`，以及`不同类型的主体内容`。

在使用下列高级选项来发送请求时，就会向服务器发送一个 `Preflight` 请求。
这种请求使用 `OPTIONS` 方法，发送下列头部。

选项 | 内容
:-- | :--
Origin | 与简单的请求相同
Access-Control-Request-Method | 请求自身使用的方法
Access-Control-Request-Headers | （可选）自定义的头部信息，多个头部以逗号分隔

以下是一个带有`自定义头部 NCZ` 的`使用 POST 方法`发送的请求

```html
Origin: http://www.nczonline.net
Access-Control-Request-Method: POST
Access-Control-Request-Headers: NCZ
```

发送这个请求后，服务器可以决定是否允许这种类型的请求。
服务器通过在`响应中发送如下头部`与浏览器进行沟通。

选项 | 内容
:-- | :--
Access-Control-Allow-Origin | 与简单的请求相同
Access-Control-Allow-Methods | 允许的方法，多个方法以逗号分隔
Access-Control-Allow-Headers | 允许的头部，多个头部以逗号分隔
Access-Control-Max-Age | 应该将这个 `Preflight` 请求缓存多长时间（以秒表示）

```html
Access-Control-Allow-Origin: http://www.nczonline.net
Access-Control-Allow-Methods: POST, GET
Access-Control-Allow-Headers: NCZ
Access-Control-Max-Age: 1728000
```

`Preflight` 请求结束后，`结果`将按照响应中指定的时间`缓存起来`。
而为此付出的代价只是第一次发送这种请求时会多一次 `HTTP` 请求。

### 带凭据的请求

默认情况下，跨源请求不提供凭据（`cookie`、`HTTP` 认证及客户端`SSL`证明等）。
通过将`withCredentials`属性设置为 `true`，可以指定某个请求应该发送凭据。

如果服务器接受带凭据的请求，会用下面的 HTTP 头部来响应。

```html
Access-Control-Allow-Credentials: true
```

如果发送的是带凭据的请求，但服务器的响应中没有包含这个头部，那么浏览器就不会把响应交给 `JavaScript`

> 于是， `responseText` 中将是空字符串， `status` 的值为 `0`，而且会调用 `onerror`() 事件处理程序。

另外，服务器还可以在 `Preflight` 响应中发送这个 `HTTP` 头部，表示允许源发送带凭据的请求。
支持 `withCredentials` 属性的浏览器有 `Firefox 3.5+`、 `Safari 4+`和 `Chrome`。 `IE 10` 及更早版本都不支持。

### 跨浏览器的CORS

即使浏览器对 CORS 的支持程度并不都一样，但所有浏览器都支持简单的（非 Preflight 和不带凭据的）请求，因此有必要实现一个跨浏览器的方案。

检测 XHR 是否支持 CORS 的最简单方式，就是检查`是否存在 withCredentials 属性`。
再结合检测 `XDomainRequest` 对象是否存在，就可以兼顾所有浏览器了。

```js
function createCORSRequest(method, url) {
    var xhr = new XMLHttpRequest();
    if ("withCredentials" in xhr) {
        xhr.open(method, url, true);
    } else if (typeof XDomainRequest != "undefined") {
        vxhr = new XDomainRequest();
        xhr.open(method, url);
    } else {
        xhr = null;
    }
    return xhr;
}
var request = createCORSRequest("get", "http://www.somewhere-else.com/page/");
if (request) {
    request.onload = function() {
        //对 request.responseText 进行处理
    };
    request.send();
}
```

`Firefox`、 `Safari` 和 `Chrome` 中的 `XMLHttpRequest` 对象与 `IE` 中的 `XDomainRequest` 对象类似，都提供了够用的接口，因此以上模式还是相当有用的。

这两个对象共同的`属性/方法`如下。

`abort()` ：用于停止正在进行的请求。
`onerror`：用于替代 onreadystatechange 检测错误。
`onload`：用于替代 onreadystatechange 检测成功。
`responseText`：用于取得响应内容。
`send()` ：用于发送请求。

以上成员都包含在 `createCORSRequest()` 函数返回的对象中，在`所有浏览器`中都能正常使用